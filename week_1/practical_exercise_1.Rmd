---
title: "practical_exercise_1, Methods 3, 2021, autumn semester"
author: '[FILL IN YOUR NAME]'
date: "[FILL IN THE DATE]"
output: html_document
---

<style type="text/css">
  body{
  font-size: 14pt;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Practical Exercise 1
The goals of today's exercise are:

1) create a _GitHub_ account and link it with _RStudio_ and create a new repository 
2) getting you back into _R_ and to get you acquainted with _Python_
3) brushing up on the general linear model

# 1) Creating a _GitHub_ account and linking it to RStudio

## _GitHub_

Go to www.github.com and sign up if you aren't already  
![__Figure__: _GitHub_'s front page](images/github_front_page.png)  
Then install _R_ and _RStudio_ if you haven't already

## _R_

### Mac and Windows
_R_ can be downloaded and installed from https://mirrors.dotsrc.org/cran/ (Danish mirror)  

### Linux
Can also be installed from the link above, but it is more convenient to use your package manager, e.g.

![__Figure__: my package manager](images/package_manager.png)

### _RStudio_ (IDE: Integrated Development Editor)

_RStudio_ can be downloaded from https://www.rstudio.com/products/rstudio/download/

## Link _GitHub_ and _RStudio_

Link your _GitHub_ account to _RStudio_ and create a repository for the assignments and practical exercises.  
Follow this tutorial: https://happygitwithr.com (Chapter 12)

# 2) Prepare your _R_ and _Python_ environments
Today's first goal is to get your _R_ and _Python_ environments up and running  

## _R_

### _R_ Packages

Make sure you can run _R Markdown_; create a new _R Markdown_ document - if you're asked to install extra packages, do so.  
We'll need more packages later, but we'll install as we go...

## _Python_

Due to the fact that _Python_ packages have a lot of interdependencies that may cause compability problems if you keep everything in one big environment, it is advisable to use a package management system like _Conda_.  
I propose using _Miniconda_ that can be downloaded from here: https://docs.conda.io/en/latest/miniconda.html (choose 64-bit)  
  
We'll not do much with it today, but will return to it for the machine learning part.  
  
An advantage is that separate environments can be maintained that are each focused on its own niche:  

![__Figure__: my environments: _mne_ is for analysis of magnetoencephalographic data, _psychopy_ is for presenting experiment scenarios, _fsl_ is for processing magnetic resonance imaging data](images/list_of_environments.png)

Then use the yml-file from _GitHub_ to create the appropriate environment:
```{bash, eval=FALSE}
# CODE TO BE RUN IN A BASH TERMINAL
## create environment
conda env create -f methods3_environment.yml
## activate environment
conda activate methods3
## after activation, you can run Spyder, (IDE)
spyder
```

![__Figure__: _Spyder_](images/spyder.png)

### Check that it works

```{python}
a = 2 + 2
b = a + 3
print(b)

a_list = [1, 'a', 2.3] # square brackets initialize lists that can contain any combination of any type of object (an integer, a string and a float in this case)
## Note that Python is zero-indexed ()
print(a_list[0]) ## prints the first entry
print(a_list[1]) ## prints the second entry
```
### Zero-indexing (reference)
https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html

# 3) Brushing up on the General Linear Model

We'll do a light start and get you back in the game of thinking about formulae and how to build your linear models  
Finally, we'll have a few exercises, finishing off today's practical exercise  

## Formulae
```{r, eval=FALSE}
formula <- y ~ x ## y as a function of x
y ~ 1 ## model the intercept for "y"
y ~ x ## model the main effect of x and the intercept for y
y ~ x + 1 ## the same as above (+ 1 is implicit)
y ~ x + 0 ## model the main effect of x and no intercept
y ~ x - 1 ## the same as above
y ~ 0 ## doesn't model anything (for completeness)
y ~ x + z ## model the main effects x and z (and an intercept)
y ~ x:z ## model interaction of x and z
y ~ x * z ## model the main effects x and z and their interaction
y ~ x + z + x:z ## the same as above
```

## mtcars (data)
Let's look at the "mtcars" data set that comes:  

_[, 1]   mpg   Miles/(US) gallon  
[, 2]	 cyl	 Number of cylinders  
[, 3]	 disp	 Displacement (cu.in.)  
[, 4]	 hp	 Gross horsepower  
[, 5]	 drat	 Rear axle ratio  
[, 6]	 wt	 Weight (lb/1000)  
[, 7]	 qsec	 1/4 mile time  
[, 8]	 vs	 V/S  
[, 9]	 am	 Transmission (0 = automatic, 1 = manual)  
[,10]	 gear	 Number of forward gears  
[,11]	 carb	 Number of carburetors_  


## Miles per gallon and weight

```{r,fig.height=5, fig.width=6}
par(font.lab=2, font.axis=2, cex=1.2)
plot(mpg ~ wt, data=mtcars, xlab='Weight (lb/1000)', ylab='Miles/(US) gallon',
     main='Scatter plot', ylim=c(0, 40))
```

Let's do a linear regression

## Now let's create some models!
```{r}
linear <- lm(mpg ~ wt, data=mtcars)
quadratic <- lm(mpg ~ I(wt^2) + wt, data=mtcars)
cubic <- lm(mpg ~ I(wt^3) + I(wt^2) + wt, data=mtcars)
```

## Plotting, linear
```{r,echo=FALSE}
logLik(linear)
```
```{r, fig.height=5, fig.width=6, echo=FALSE}
par(font=2, font.lab=2, font.axis=2, lwd=3)
plot(mpg ~ wt, data=mtcars, xlab='weight (lb/1000)')
abline(linear, lty=1)
legend('topright','linear', lty=1)
```

## Plotting, quadratic
```{r,echo=FALSE}
logLik(quadratic)
```
```{r, fig.height=5, fig.width=6, echo=FALSE}
par(font=2, font.lab=2, font.axis=2, lwd=3)
plot(mpg ~ wt, data=mtcars, xlab='weight (lb/1000)')
abline(linear, lty=1)
coef.q <- coefficients(quadratic)
fit.q <- coef.q[2] * mtcars$wt^2 + coef.q[3] * mtcars$wt + coef.q[1]
lines(sort(mtcars$wt), rev(sort(fit.q)), lty=2)
legend('topright', c('linear', 'quadratic'), lty=1:2)
```

## Plotting, cubic
```{r,echo=FALSE}
logLik(cubic)
```
```{r, fig.height=5, fig.width=6, echo=FALSE}
par(font=2, font.lab=2, font.axis=2, lwd=3)
plot(mpg ~ wt, data=mtcars, xlab='weight (lb/1000)')
abline(linear, lty=1)
coef.q <- coefficients(quadratic)
fit.q <- coef.q[2] * mtcars$wt^2 + coef.q[3] * mtcars$wt + coef.q[1]
coef.c <- coefficients(cubic)
fit.c <- coef.c[2] * mtcars$wt^3 + coef.c[3] * mtcars$wt^2 + coef.c[4] * mtcars$wt + coef.c[1]
lines(sort(mtcars$wt), rev(sort(fit.q)), lty=2)
lines(sort(mtcars$wt), rev(sort(fit.c)), lty=3)
legend('topright', c('linear', 'quadratic', 'cubic'), lty=1:3)
```